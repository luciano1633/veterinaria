<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Sistema de Gestión Veterinaria&#10;&#10;## Descripción&#10;Aplicación de consola en Kotlin para gestionar consultas veterinarias. Permite registrar mascotas y dueños, calcular costos con descuentos, verificar disponibilidad, agendar consultas y enviar recordatorios.&#10;&#10;## Arquitectura Actual (Refactor según retroalimentación)&#10;Se segmentó la lógica para mejorar mantenibilidad:&#10;- `model/` contiene entidades (POJOs/Kotlin classes).&#10;- `repository/AgendaRepository.kt` gestiona horarios ocupados (persistencia en memoria).&#10;- `service/AgendaService.kt` asigna consultas aplicando reglas de disponibilidad.&#10;- `service/ReporteService.kt` centraliza la generación de resúmenes profesionales (string builder).&#10;- `util/Parsers.kt` reduce uso de try/catch mediante `runCatching` para fecha/hora.&#10;- `Utils.kt` centraliza validaciones (email, teléfono, normalización).&#10;- `Main.kt` orquesta el flujo, delegando lógica de negocio a servicios y utilidades.&#10;&#10;## Cambios recientes&#10;- Centralización de validaciones en `Validaciones` (`validarEmail`, `validarTelefono`, `normalizarEmail`).&#10;- Refactor: se crean `AgendaRepository`, `AgendaService`, `Parsers`, `ReporteService` para elevar niveles de evaluación (funciones reutilizables, manejo de errores, resumen profesional, organización de código).&#10;- Uso ampliado de colecciones: `MutableList`, `MutableSet`, `MutableMap` y acceso seguro.&#10;- Resumen profesional único vía `ReporteService.resumen`.&#10;&#10;## Resultados esperados vs rúbrica del profesor&#10;Niveles apuntados tras el refactor:&#10;- Flujos de decisión (if/when) + colecciones y strings: CL.&#10;- Funciones reutilizables y colecciones (listOf, set, map): buscar elevar a CL (se añadieron servicios especializados y repositorio).&#10;- Clases representativas y encapsulación: CL (servicios y repositorio refuerzan el diseño).&#10;- Manejo de errores y null-safety (try-catch, runCatching, operadores seguros): mejorar a CL (introducción de Parsers reduce excepciones manuales y normaliza parseo).&#10;- Resumen profesional con formateo: subir a CL (uso de `buildString` en `ReporteService`).&#10;- Código limpio y organizado: subir de ML a L/CL (separación de responsabilidades y nombres consistentes).&#10;&#10;## Cumplimiento de la pauta (detalle)&#10;- Flujos de decisión: `if` y `when` en dosis, tipo de vacuna, validaciones y reglas de clínica.&#10;- Uso de colecciones y strings: listas para entidades, mapas para agenda, sets para unicidad, regex y plantillas `${}` en reportes.&#10;- Funciones reutilizables: métodos en servicios (`AgendaService.asignar`), repositorio (`ocupar/reservar`), utilidades (`Parsers`, `Validaciones`), cálculo (`calcularCostoConDescuento`, `calcularDosis`).&#10;- Organización: separación clara en paquetes (`model`, `repository`, `service`, `util`).&#10;- Clases representativas: `Usuario`, `Dueno`, `Veterinario`, `Mascota`, `Consulta`, más servicios y repositorio.&#10;- Manejo de errores: `runCatching` en `Parsers`, try/catch aislado, operadores seguros `?.` y Elvis `?:`.&#10;- Resumen profesional: `ReporteService.resumen` produce salida estructurada.&#10;- Código limpio: responsabilidades distribuidas, menor densidad en `Main.kt`.&#10;&#10;## Estructura del proyecto&#10;```&#10;veterinaria/&#10;├── src/&#10;│   ├── Main.kt&#10;│   ├── Utils.kt&#10;│   ├── model/&#10;│   │   ├── Usuario.kt&#10;│   │   ├── Dueño.kt (Dueno)&#10;│   │   ├── Veterinario.kt&#10;│   │   ├── Mascota.kt&#10;│   │   └── Consulta.kt&#10;│   ├── repository/&#10;│   │   └── AgendaRepository.kt&#10;│   ├── service/&#10;│   │   ├── AgendaService.kt&#10;│   │   └── ReporteService.kt&#10;│   └── util/&#10;│       └── Parsers.kt&#10;├── README.md&#10;└── veterinaria.iml&#10;```&#10;&#10;## Cómo ejecutar&#10;- Abrir en IntelliJ IDEA y ejecutar `Main.kt`.&#10;- Seguir prompts: registrar mascotas, dueño, asignar horarios, ver resumen e informes.&#10;&#10;## Próximos pasos sugeridos&#10;- Persistencia (Archivos JSON o BD ligera).&#10;- Tests unitarios (JUnit) para `Validaciones`, `AgendaService`, `Parsers`, `ReporteService`.&#10;- Manejo de estados avanzados (cancelada, reprogramada) en `Consulta`.&#10;- Exportar resumen a archivo (TXT/JSON) y empaquetar ZIP automático.&#10;&#10;## Licencia&#10;Proyecto educativo.&#10;" />
              <option name="updatedContent" value="# Sistema de Gestión Veterinaria&#10;&#10;## Descripción&#10;Aplicación de consola en Kotlin para gestionar consultas veterinarias. Permite registrar mascotas y dueños, calcular costos con descuentos, verificar disponibilidad, agendar consultas y enviar recordatorios.&#10;&#10;## Arquitectura Actual (Refactor según retroalimentación)&#10;- model/: entidades.&#10;- repository/AgendaRepository.kt: horarios ocupados.&#10;- service/AgendaService.kt: asignación de consultas.&#10;- service/ReporteService.kt: resumen profesional y exportación a archivo.&#10;- util/Parsers.kt: parseo seguro de fecha/hora (runCatching).&#10;- util/ZipUtil.kt: generación de ZIP del resumen.&#10;- Utils.kt: validaciones (email/teléfono).&#10;- Main.kt: orquestación del flujo.&#10;&#10;## Cambios recientes&#10;- Validaciones centralizadas: `Validaciones` (email, teléfono, normalización).&#10;- Servicios y repositorio: `AgendaService`, `AgendaRepository`.&#10;- Parsers: menos try/catch en Main mediante `runCatching`.&#10;- Reporte profesional y exportación: `ReporteService.resumen/exportar`.&#10;- Generación automática de ZIP: `ZipUtil.zipDir(&quot;salida&quot;, &quot;salida/resumen.zip&quot;)` desde `Main.kt`.&#10;&#10;## Cumplimiento de la pauta (y mejora de niveles)&#10;- If/when + colecciones + strings: CL.&#10;- Funciones reutilizables + colecciones (listOf, set, map): L → fortalecidas con servicios/repositorio.&#10;- Clases representativas y encapsulación: CL.&#10;- try-catch + null-safety: L → reforzado con Parsers (`runCatching`) y operadores seguros.&#10;- Resumen claro con plantillas: L → reforzado con `ReporteService` y exportación.&#10;- Código limpio y organizado: ML → mejorado con separación por capas y nombres descriptivos.&#10;- Entrega del resumen en ZIP: ML → ahora automático en `salida/resumen.zip` al ejecutar.&#10;&#10;## Ejecución rápida&#10;- Ejecuta `Main.kt` en IntelliJ. Al finalizar:&#10;  - Se muestra el resumen en consola.&#10;  - Se guarda en `salida/resumen.txt`.&#10;  - Se genera `salida/resumen.zip` automáticamente.&#10;&#10;## Próximos pasos&#10;- Añadir pruebas unitarias (JUnit) para `Validaciones`, `Parsers`, `AgendaService`, `ReporteService`.&#10;- Persistencia (JSON/DB) para consultas y usuarios.&#10;- Estados avanzados de consulta (cancelada, reprogramada) y validaciones extra.&#10;&#10;## Licencia&#10;Proyecto educativo." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Main.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Main.kt" />
              <option name="originalContent" value="package main&#10;&#10;import java.time.LocalDate&#10;import java.time.LocalTime&#10;import java.time.DayOfWeek&#10;import main.model.*&#10;import main.repository.AgendaRepository&#10;import main.service.AgendaService&#10;import main.service.ReporteService&#10;import main.util.Parsers&#10;&#10;val veterinarios = mutableListOf&lt;Veterinario&gt;()&#10;val consultas = mutableListOf&lt;Consulta&gt;()&#10;val agendaPorVeterinario = mutableMapOf&lt;String, MutableList&lt;Consulta&gt;&gt;()&#10;val nombresVeterinarios: MutableSet&lt;String&gt; = mutableSetOf()&#10;val especialidadesVeterinarios: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;fun main() {&#10;    println(&quot;Bienvenido al sistema de la veterinaria.&quot;)&#10;&#10;    // Inicializar algunos veterinarios de ejemplo (nombre, telefono, especialidad, email)&#10;    veterinarios.add(Veterinario(&quot;Dr. Gonzalez&quot;, &quot;22220001&quot;, &quot;General&quot;, &quot;gonzalez@vet.com&quot;))&#10;    veterinarios.add(Veterinario(&quot;Dra. Perez&quot;, &quot;22220002&quot;, &quot;Dermatologia&quot;, &quot;perez@vet.com&quot;))&#10;&#10;    // Actualizar conjuntos a partir de la lista para garantizar unicidad&#10;    nombresVeterinarios.addAll(veterinarios.map { it.nombre })&#10;    especialidadesVeterinarios.addAll(veterinarios.map { it.especialidad })&#10;&#10;    // Inicializar servicios y repositorio&#10;    val agendaRepo = AgendaRepository()&#10;    val agendaService = AgendaService(agendaRepo, veterinarios)&#10;&#10;    // Paso 3: Preguntar número de mascotas primero para el descuento&#10;    var numeroMascotas: Int&#10;    while (true) {&#10;        println(&quot;Ingrese el número de mascotas que seran atendidas:&quot;)&#10;        val input = readLine()?.toIntOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            numeroMascotas = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    val costoBase = 5000.0 // Costo base por consulta&#10;    val costoFinal = calcularCostoConDescuento(costoBase, numeroMascotas)&#10;&#10;    // Paso 2: Entrada de datos para mascotas (repetir si hay más de una)&#10;    val mascotas = mutableListOf&lt;Mascota&gt;()&#10;    for (i in 1..numeroMascotas) {&#10;        println(&quot;Registrando mascota $i:&quot;)&#10;        mascotas.add(registrarMascota())&#10;    }&#10;&#10;    // Registrar dueño (uno solo)&#10;    val dueno = registrarDueno()&#10;&#10;    // Crear consulta(s) y asignar dueños/mascotas&#10;    var idCounter = consultas.size + 1&#10;    mascotas.forEach { m -&gt;&#10;        val c = Consulta(idCounter++, &quot;Consulta general - ${m.nombre}&quot;, costoFinal)&#10;        // Asignar la misma instancia del dueño registrada&#10;        c.dueno = dueno&#10;        c.mascota = m&#10;        consultas.add(c)&#10;    }&#10;&#10;    // Asignación usando AgendaService&#10;    consultas.filter { it.estado == &quot;Pendiente&quot; }.forEach { c -&gt;&#10;        while (true) {&#10;            val (fecha, hora) = solicitarFechaHoraConParsers()&#10;            if (!verificarReglasClinica(fecha, hora)) {&#10;                println(&quot;Horario fuera de reglas de la clínica o inválido: $fecha $hora&quot;)&#10;                continue&#10;            }&#10;            if (agendaService.asignar(c, fecha, hora)) {&#10;                agendaPorVeterinario.getOrPut(c.veterinario!!.nombre) { mutableListOf() }.add(c)&#10;                println(&quot;Consulta ${c.idConsulta} asignada a ${c.veterinario!!.nombre} en $fecha $hora&quot;)&#10;                break&#10;            } else {&#10;                println(&quot;No disponible $fecha $hora. ¿Intentar otra? (s/n):&quot;)&#10;                val resp = leerSN() ?: break&#10;                if (resp == 'n') break&#10;            }&#10;        }&#10;    }&#10;&#10;    // Resumen profesional usando ReporteService&#10;    println(&quot;\n--- Resumen Profesional ---&quot;)&#10;    val resumen = ReporteService.resumen(dueno, mascotas)&#10;    println(resumen)&#10;    val ruta = ReporteService.exportar(dueno, mascotas)&#10;    println(&quot;Resumen exportado en: $ruta&quot;)&#10;&#10;    // Informe de todas las consultas&#10;    generarInformeConsultas()&#10;&#10;    // Enviar recordatorios (simulado)&#10;    enviarRecordatorios()&#10;}&#10;&#10;fun enviarRecordatorios() {&#10;    println(&quot;\n--- Enviando recordatorios ---&quot;)&#10;    // Recordatorios de citas programadas&#10;    consultas.filter { it.estado == &quot;Pendiente&quot; &amp;&amp; it.fecha != null &amp;&amp; it.hora != null }.forEach { c -&gt;&#10;        val email = c.dueno?.email&#10;        if (email != null &amp;&amp; Validaciones.validarEmail(email)) {&#10;            println(&quot;[MAIL] Recordatorio de cita enviado a $email: Consulta ${c.idConsulta} el ${c.fecha} ${c.hora}&quot;)&#10;        } else {&#10;            println(&quot;[SKIP] Email inválido para la consulta ${c.idConsulta}, no se envió recordatorio.&quot;)&#10;        }&#10;    }&#10;&#10;    // Recordatorios de vacunación próximos (en 30 días)&#10;    val hoy = LocalDate.now()&#10;    consultas.forEach { c -&gt;&#10;        val m = c.mascota ?: return@forEach&#10;        val d = c.dueno&#10;        val prox = m.calcularProximaVacuna()&#10;        if (prox != null) {&#10;            try {&#10;                val dias = java.time.temporal.ChronoUnit.DAYS.between(hoy, prox)&#10;                if (dias in 0..30) {&#10;                    val email = d?.email&#10;                    if (email != null &amp;&amp; Validaciones.validarEmail(email)) {&#10;                        println(&quot;[MAIL] Recordatorio de vacunación enviado a $email: Mascota ${m.nombre} tiene vacunación el $prox&quot;)&#10;                    } else {&#10;                        println(&quot;[SKIP] Email inválido para vacunación de ${m.nombre}&quot;)&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;                // ignore parsing issues&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Se reemplaza por la función centralizada en Utils.kt&#10;fun validarEmailConDefault(email: String?): String {&#10;    return Validaciones.normalizarEmail(email)&#10;}&#10;&#10;fun calcularDosis(peso: Double, edad: Int): String {&#10;    // Ejemplo simple: dosis en mg según peso y edad&#10;    val factor = when {&#10;        peso &lt; 5 -&gt; 5&#10;        peso &lt; 15 -&gt; 10&#10;        else -&gt; 20&#10;    }&#10;    val ajuste = if (edad &lt; 1) 0.8 else 1.0&#10;    val dosis = factor * ajuste&#10;    return &quot;${dosis}mg&quot;&#10;}&#10;&#10;fun generarInformeConsultas() {&#10;    println(&quot;\n--- Informe de Consultas Registradas ---&quot;)&#10;    consultas.forEach { c -&gt;&#10;        println(c.generarResumen())&#10;    }&#10;    val pendientes = consultas.filter { it.estado == &quot;Pendiente&quot; }&#10;    println(&quot;\nPendientes (${pendientes.size}):&quot;)&#10;    pendientes.forEach { println(it.generarResumen()) }&#10;}&#10;&#10;fun leerSN(): Char? {&#10;    while (true) {&#10;        val input = readLine()?.lowercase() ?: return null&#10;        if (input == &quot;s&quot; || input == &quot;n&quot;) return input[0]&#10;        println(&quot;Caracter invalido. Solo 's' o 'n'.&quot;)&#10;    }&#10;}&#10;&#10;fun registrarMascota(): Mascota {&#10;    var nombre: String&#10;    while (true) {&#10;        println(&quot;Ingrese el nombre de la mascota:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (input.isNotEmpty() &amp;&amp; input.all { it.isLetter() || it == ' ' }) {&#10;            nombre = input&#10;            break&#10;        } else {&#10;            println(&quot;Nombre inválido. Solo se permiten letras y espacios.&quot;)&#10;        }&#10;    }&#10;    var especie: String&#10;    while (true) {&#10;        println(&quot;Ingrese la especie:&quot;)&#10;        val input = readLine()?.lowercase() ?: &quot;&quot;&#10;        if (input == &quot;perro&quot; || input == &quot;gato&quot;) {&#10;            especie = input&#10;            break&#10;        } else {&#10;            println(&quot;Especie no valida. Solo se permiten 'perro' o 'gato'.&quot;)&#10;        }&#10;    }&#10;    var edad: Int&#10;    while (true) {&#10;        println(&quot;Ingrese la edad (en años):&quot;)&#10;        val input = readLine()?.toIntOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            edad = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    var peso: Double&#10;    while (true) {&#10;        println(&quot;Ingrese el peso (en kg):&quot;)&#10;        val input = readLine()?.toDoubleOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            peso = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    return Mascota(nombre, especie, edad, peso)&#10;}&#10;&#10;fun registrarDueno(): Dueno {&#10;    var nombreDueno: String&#10;    while (true) {&#10;        println(&quot;Ingrese el nombre del dueño:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (input.isNotEmpty() &amp;&amp; input.all { it.isLetter() || it == ' ' }) {&#10;            nombreDueno = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter invalido. Solo se permiten letras y espacios.&quot;)&#10;        }&#10;    }&#10;    var telefono: String&#10;    while (true) {&#10;        println(&quot;Ingrese el telefono:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (Validaciones.validarTelefono(input)) {&#10;            telefono = input&#10;            break&#10;        } else {&#10;            println(&quot;Numero telefonico invalido. Debe tener exactamente 8 digitos numericos.&quot;)&#10;        }&#10;    }&#10;    println(&quot;Ingrese el email (opcional):&quot;)&#10;    val emailInput = readLine()&#10;    val email = validarEmailConDefault(emailInput)&#10;    return Dueno(nombreDueno, telefono, email)&#10;}&#10;&#10;fun calcularCostoConDescuento(costoBase: Double, numeroMascotas: Int): Double {&#10;    val descuento = if (numeroMascotas &gt; 1) 0.15 else 0.0&#10;    return costoBase * (1 - descuento)&#10;}&#10;&#10;fun solicitarFechaHoraConParsers(): Pair&lt;String, String&gt; {&#10;    val fecha = solicitarFechaConParsers()&#10;    val hora = solicitarHoraConParsers()&#10;    return fecha to hora&#10;}&#10;&#10;fun solicitarFechaConParsers(): String {&#10;    while (true) {&#10;        println(&quot;Ingrese la fecha (YYYY-MM-DD):&quot;)&#10;        val raw = readLine() ?: &quot;&quot;&#10;        val r = Parsers.fecha(raw)&#10;        if (r.isSuccess) return raw else println(&quot;Fecha inválida.&quot;)&#10;    }&#10;}&#10;&#10;fun solicitarHoraConParsers(): String {&#10;    while (true) {&#10;        println(&quot;Ingrese la hora (HH:MM):&quot;)&#10;        val raw = readLine() ?: &quot;&quot;&#10;        val r = Parsers.hora(raw)&#10;        if (r.isSuccess) return raw else println(&quot;Hora inválida.&quot;)&#10;    }&#10;}&#10;&#10;fun verificarReglasClinica(fecha: String, hora: String): Boolean {&#10;    return try {&#10;        val date = LocalDate.parse(fecha)&#10;        if (date.dayOfWeek == DayOfWeek.SUNDAY) return false&#10;        val time = LocalTime.parse(hora)&#10;        val start = LocalTime.of(8, 0)&#10;        val end = LocalTime.of(16, 0)&#10;        !time.isBefore(start) &amp;&amp; !time.isAfter(end)&#10;    } catch (_: Exception) { false }&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import java.time.LocalDate&#10;import java.time.LocalTime&#10;import java.time.DayOfWeek&#10;import main.model.*&#10;import main.repository.AgendaRepository&#10;import main.service.AgendaService&#10;import main.service.ReporteService&#10;import main.util.Parsers&#10;import main.util.ZipUtil&#10;import java.nio.file.Paths&#10;&#10;val veterinarios = mutableListOf&lt;Veterinario&gt;()&#10;val consultas = mutableListOf&lt;Consulta&gt;()&#10;val agendaPorVeterinario = mutableMapOf&lt;String, MutableList&lt;Consulta&gt;&gt;()&#10;val nombresVeterinarios: MutableSet&lt;String&gt; = mutableSetOf()&#10;val especialidadesVeterinarios: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;fun main() {&#10;    println(&quot;Bienvenido al sistema de la veterinaria.&quot;)&#10;&#10;    // Inicializar algunos veterinarios de ejemplo (nombre, telefono, especialidad, email)&#10;    veterinarios.add(Veterinario(&quot;Dr. Gonzalez&quot;, &quot;22220001&quot;, &quot;General&quot;, &quot;gonzalez@vet.com&quot;))&#10;    veterinarios.add(Veterinario(&quot;Dra. Perez&quot;, &quot;22220002&quot;, &quot;Dermatologia&quot;, &quot;perez@vet.com&quot;))&#10;&#10;    // Actualizar conjuntos a partir de la lista para garantizar unicidad&#10;    nombresVeterinarios.addAll(veterinarios.map { it.nombre })&#10;    especialidadesVeterinarios.addAll(veterinarios.map { it.especialidad })&#10;&#10;    // Inicializar servicios y repositorio&#10;    val agendaRepo = AgendaRepository()&#10;    val agendaService = AgendaService(agendaRepo, veterinarios)&#10;&#10;    // Paso 3: Preguntar número de mascotas primero para el descuento&#10;    var numeroMascotas: Int&#10;    while (true) {&#10;        println(&quot;Ingrese el número de mascotas que seran atendidas:&quot;)&#10;        val input = readLine()?.toIntOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            numeroMascotas = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    val costoBase = 5000.0 // Costo base por consulta&#10;    val costoFinal = calcularCostoConDescuento(costoBase, numeroMascotas)&#10;&#10;    // Paso 2: Entrada de datos para mascotas (repetir si hay más de una)&#10;    val mascotas = mutableListOf&lt;Mascota&gt;()&#10;    for (i in 1..numeroMascotas) {&#10;        println(&quot;Registrando mascota $i:&quot;)&#10;        mascotas.add(registrarMascota())&#10;    }&#10;&#10;    // Registrar dueño (uno solo)&#10;    val dueno = registrarDueno()&#10;&#10;    // Crear consulta(s) y asignar dueños/mascotas&#10;    var idCounter = consultas.size + 1&#10;    mascotas.forEach { m -&gt;&#10;        val c = Consulta(idCounter++, &quot;Consulta general - ${m.nombre}&quot;, costoFinal)&#10;        // Asignar la misma instancia del dueño registrada&#10;        c.dueno = dueno&#10;        c.mascota = m&#10;        consultas.add(c)&#10;    }&#10;&#10;    // Asignación usando AgendaService&#10;    consultas.filter { it.estado == &quot;Pendiente&quot; }.forEach { c -&gt;&#10;        while (true) {&#10;            val (fecha, hora) = solicitarFechaHoraConParsers()&#10;            if (!verificarReglasClinica(fecha, hora)) {&#10;                println(&quot;Horario fuera de reglas de la clínica o inválido: $fecha $hora&quot;)&#10;                continue&#10;            }&#10;            if (agendaService.asignar(c, fecha, hora)) {&#10;                agendaPorVeterinario.getOrPut(c.veterinario!!.nombre) { mutableListOf() }.add(c)&#10;                println(&quot;Consulta ${c.idConsulta} asignada a ${c.veterinario!!.nombre} en $fecha $hora&quot;)&#10;                break&#10;            } else {&#10;                println(&quot;No disponible $fecha $hora. ¿Intentar otra? (s/n):&quot;)&#10;                val resp = leerSN() ?: break&#10;                if (resp == 'n') break&#10;            }&#10;        }&#10;    }&#10;&#10;    // Resumen profesional usando ReporteService&#10;    println(&quot;\n--- Resumen Profesional ---&quot;)&#10;    val resumen = ReporteService.resumen(dueno, mascotas)&#10;    println(resumen)&#10;    val ruta = ReporteService.exportar(dueno, mascotas)&#10;    println(&quot;Resumen exportado en: $ruta&quot;)&#10;    try {&#10;        val zipPath = Paths.get(&quot;salida&quot;, &quot;resumen.zip&quot;)&#10;        ZipUtil.zipDir(Paths.get(&quot;salida&quot;), zipPath)&#10;        println(&quot;Archivo ZIP generado en: $zipPath&quot;)&#10;    } catch (e: Exception) {&#10;        println(&quot;No se pudo generar el ZIP: ${e.message}&quot;)&#10;    }&#10;&#10;    // Informe de todas las consultas&#10;    generarInformeConsultas()&#10;&#10;    // Enviar recordatorios (simulado)&#10;    enviarRecordatorios()&#10;}&#10;&#10;fun enviarRecordatorios() {&#10;    println(&quot;\n--- Enviando recordatorios ---&quot;)&#10;    // Recordatorios de citas programadas&#10;    consultas.filter { it.estado == &quot;Pendiente&quot; &amp;&amp; it.fecha != null &amp;&amp; it.hora != null }.forEach { c -&gt;&#10;        val email = c.dueno?.email&#10;        if (email != null &amp;&amp; Validaciones.validarEmail(email)) {&#10;            println(&quot;[MAIL] Recordatorio de cita enviado a $email: Consulta ${c.idConsulta} el ${c.fecha} ${c.hora}&quot;)&#10;        } else {&#10;            println(&quot;[SKIP] Email inválido para la consulta ${c.idConsulta}, no se envió recordatorio.&quot;)&#10;        }&#10;    }&#10;&#10;    // Recordatorios de vacunación próximos (en 30 días)&#10;    val hoy = LocalDate.now()&#10;    consultas.forEach { c -&gt;&#10;        val m = c.mascota ?: return@forEach&#10;        val d = c.dueno&#10;        val prox = m.calcularProximaVacuna()&#10;        if (prox != null) {&#10;            try {&#10;                val dias = java.time.temporal.ChronoUnit.DAYS.between(hoy, prox)&#10;                if (dias in 0..30) {&#10;                    val email = d?.email&#10;                    if (email != null &amp;&amp; Validaciones.validarEmail(email)) {&#10;                        println(&quot;[MAIL] Recordatorio de vacunación enviado a $email: Mascota ${m.nombre} tiene vacunación el $prox&quot;)&#10;                    } else {&#10;                        println(&quot;[SKIP] Email inválido para vacunación de ${m.nombre}&quot;)&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;                // ignore parsing issues&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Se reemplaza por la función centralizada en Utils.kt&#10;fun validarEmailConDefault(email: String?): String {&#10;    return Validaciones.normalizarEmail(email)&#10;}&#10;&#10;fun calcularDosis(peso: Double, edad: Int): String {&#10;    // Ejemplo simple: dosis en mg según peso y edad&#10;    val factor = when {&#10;        peso &lt; 5 -&gt; 5&#10;        peso &lt; 15 -&gt; 10&#10;        else -&gt; 20&#10;    }&#10;    val ajuste = if (edad &lt; 1) 0.8 else 1.0&#10;    val dosis = factor * ajuste&#10;    return &quot;${dosis}mg&quot;&#10;}&#10;&#10;fun generarInformeConsultas() {&#10;    println(&quot;\n--- Informe de Consultas Registradas ---&quot;)&#10;    consultas.forEach { c -&gt;&#10;        println(c.generarResumen())&#10;    }&#10;    val pendientes = consultas.filter { it.estado == &quot;Pendiente&quot; }&#10;    println(&quot;\nPendientes (${pendientes.size}):&quot;)&#10;    pendientes.forEach { println(it.generarResumen()) }&#10;}&#10;&#10;fun leerSN(): Char? {&#10;    while (true) {&#10;        val input = readLine()?.lowercase() ?: return null&#10;        if (input == &quot;s&quot; || input == &quot;n&quot;) return input[0]&#10;        println(&quot;Caracter invalido. Solo 's' o 'n'.&quot;)&#10;    }&#10;}&#10;&#10;fun registrarMascota(): Mascota {&#10;    var nombre: String&#10;    while (true) {&#10;        println(&quot;Ingrese el nombre de la mascota:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (input.isNotEmpty() &amp;&amp; input.all { it.isLetter() || it == ' ' }) {&#10;            nombre = input&#10;            break&#10;        } else {&#10;            println(&quot;Nombre inválido. Solo se permiten letras y espacios.&quot;)&#10;        }&#10;    }&#10;    var especie: String&#10;    while (true) {&#10;        println(&quot;Ingrese la especie:&quot;)&#10;        val input = readLine()?.lowercase() ?: &quot;&quot;&#10;        if (input == &quot;perro&quot; || input == &quot;gato&quot;) {&#10;            especie = input&#10;            break&#10;        } else {&#10;            println(&quot;Especie no valida. Solo se permiten 'perro' o 'gato'.&quot;)&#10;        }&#10;    }&#10;    var edad: Int&#10;    while (true) {&#10;        println(&quot;Ingrese la edad (en años):&quot;)&#10;        val input = readLine()?.toIntOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            edad = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    var peso: Double&#10;    while (true) {&#10;        println(&quot;Ingrese el peso (en kg):&quot;)&#10;        val input = readLine()?.toDoubleOrNull()&#10;        if (input != null &amp;&amp; input &gt; 0) {&#10;            peso = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter no valido. Por favor ingresar un numero valido.&quot;)&#10;        }&#10;    }&#10;    return Mascota(nombre, especie, edad, peso)&#10;}&#10;&#10;fun registrarDueno(): Dueno {&#10;    var nombreDueno: String&#10;    while (true) {&#10;        println(&quot;Ingrese el nombre del dueño:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (input.isNotEmpty() &amp;&amp; input.all { it.isLetter() || it == ' ' }) {&#10;            nombreDueno = input&#10;            break&#10;        } else {&#10;            println(&quot;Caracter invalido. Solo se permiten letras y espacios.&quot;)&#10;        }&#10;    }&#10;    var telefono: String&#10;    while (true) {&#10;        println(&quot;Ingrese el telefono:&quot;)&#10;        val input = readLine() ?: &quot;&quot;&#10;        if (Validaciones.validarTelefono(input)) {&#10;            telefono = input&#10;            break&#10;        } else {&#10;            println(&quot;Numero telefonico invalido. Debe tener exactamente 8 digitos numericos.&quot;)&#10;        }&#10;    }&#10;    println(&quot;Ingrese el email (opcional):&quot;)&#10;    val emailInput = readLine()&#10;    val email = validarEmailConDefault(emailInput)&#10;    return Dueno(nombreDueno, telefono, email)&#10;}&#10;&#10;fun calcularCostoConDescuento(costoBase: Double, numeroMascotas: Int): Double {&#10;    val descuento = if (numeroMascotas &gt; 1) 0.15 else 0.0&#10;    return costoBase * (1 - descuento)&#10;}&#10;&#10;fun solicitarFechaHoraConParsers(): Pair&lt;String, String&gt; {&#10;    val fecha = solicitarFechaConParsers()&#10;    val hora = solicitarHoraConParsers()&#10;    return fecha to hora&#10;}&#10;&#10;fun solicitarFechaConParsers(): String {&#10;    while (true) {&#10;        println(&quot;Ingrese la fecha (YYYY-MM-DD):&quot;)&#10;        val raw = readLine() ?: &quot;&quot;&#10;        val r = Parsers.fecha(raw)&#10;        if (r.isSuccess) return raw else println(&quot;Fecha inválida.&quot;)&#10;    }&#10;}&#10;&#10;fun solicitarHoraConParsers(): String {&#10;    while (true) {&#10;        println(&quot;Ingrese la hora (HH:MM):&quot;)&#10;        val raw = readLine() ?: &quot;&quot;&#10;        val r = Parsers.hora(raw)&#10;        if (r.isSuccess) return raw else println(&quot;Hora inválida.&quot;)&#10;    }&#10;}&#10;&#10;fun verificarReglasClinica(fecha: String, hora: String): Boolean {&#10;    return try {&#10;        val date = LocalDate.parse(fecha)&#10;        if (date.dayOfWeek == DayOfWeek.SUNDAY) return false&#10;        val time = LocalTime.parse(hora)&#10;        val start = LocalTime.of(8, 0)&#10;        val end = LocalTime.of(16, 0)&#10;        !time.isBefore(start) &amp;&amp; !time.isAfter(end)&#10;    } catch (_: Exception) { false }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/util/ZipUtil.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/util/ZipUtil.kt" />
              <option name="updatedContent" value="package main.util&#10;&#10;import java.io.IOException&#10;import java.nio.file.*&#10;import java.util.zip.ZipEntry&#10;import java.util.zip.ZipOutputStream&#10;&#10;object ZipUtil {&#10;    @Throws(IOException::class)&#10;    fun zipDir(sourceDir: Path, zipFile: Path) {&#10;        if (!Files.exists(sourceDir)) return&#10;        Files.newOutputStream(zipFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING).use { fos -&gt;&#10;            ZipOutputStream(fos).use { zos -&gt;&#10;                Files.walk(sourceDir).use { stream -&gt;&#10;                    stream.filter { Files.isRegularFile(it) }.forEach { file -&gt;&#10;                        val entryName = sourceDir.relativize(file).toString().replace('\\', '/')&#10;                        val entry = ZipEntry(entryName)&#10;                        zos.putNextEntry(entry)&#10;                        Files.newInputStream(file).use { input -&gt;&#10;                            input.copyTo(zos)&#10;                        }&#10;                        zos.closeEntry()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>